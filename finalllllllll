'''
*****************************************************************************************
*
*        		===============================================
*           		GeoGuide(GG) Theme (eYRC 2023-24)
*        		===============================================
*
*  This script is to implement Task 1A of GeoGuide(GG) Theme (eYRC 2023-24).
*  
*  This software is made available on an "AS IS WHERE IS BASIS".
*  Licensee/end user indemnifies and will keep e-Yantra indemnified from
*  any and all claim(s) that emanate from the use of the Software or 
*  breach of the terms of this agreement.
*
*****************************************************************************************
'''

# Team ID:			[ Team-ID ]
# Author List:		[ Names of team members worked on this file separated by Comma: Name1, Name2, ... ]
# Filename:			task_1a.py
# Functions:	    [`load_dataset`, `data_preprocessing`, `identify_features_and_targets`,
# 					 `data_scaling`, `load_as_tensors`, `Salary_Predictor`, `train_model`,
# 					 `evaluate_model` ]

####################### IMPORT MODULES #######################
import pandas as pd
import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from torch.utils.data import DataLoader, TensorDataset
###################### Additional Imports ####################
'''
You can import any additional modules that you require from 
torch, matplotlib or sklearn. 
You are NOT allowed to import any other libraries. It will 
cause errors while running the executable
'''
##############################################################

################# ADD UTILITY FUNCTIONS HERE #################

# Load your dataset (replace 'your_dataset.csv' with your actual dataset file)
def load_dataset(file_path):
    # Load dataset using pandas
    data = pd.read_csv(file_path)
    return data

##############################################################

# Data Preprocessing
def data_preprocessing(task_1a_dataframe):
    '''
    Purpose:
    ---
    This function will be used to load your csv dataset and preprocess it.
    Preprocessing involves cleaning the dataset by removing unwanted features,
    decision about what needs to be done with missing values etc. Note that 
    there are features in the csv file whose values are textual (eg: Industry, 
    Education Level etc) These features might be required for training the model
    but can not be given directly as strings for training. Hence this function 
    should return encoded dataframe in which all the textual features are 
    numerically labeled.

    Input Arguments:
    ---
    `task_1a_dataframe`: [Dataframe]
                       Pandas dataframe read from the provided dataset 

    Returns:
    ---
    `encoded_dataframe`: [Dataframe]
                        Pandas dataframe that has all the features mapped to 
                        numbers starting from zero

    Example call:
    ---
    encoded_dataframe = data_preprocessing(task_1a_dataframe)
    '''

    #################    ADD YOUR CODE HERE    ##################
    # Encode categorical variables using OneHotEncoder
    categorical_columns = ['Education', 'City', 'Gender', 'EverBenched']
    
    onehot_encoder = OneHotEncoder(sparse=False)
    for column in categorical_columns:
        encoded_columns = onehot_encoder.fit_transform(task_1a_dataframe[column].values.reshape(-1, 1))
        encoded_df = pd.DataFrame(encoded_columns, columns=[f'{column}_{i}' for i in range(encoded_columns.shape[1])])
        task_1a_dataframe = pd.concat([task_1a_dataframe, encoded_df], axis=1)
        task_1a_dataframe.drop([column], axis=1, inplace=True)

    # Handle missing values (you can choose a suitable strategy)
    task_1a_dataframe.fillna(0, inplace=True)  # Replace missing values with 0 for demonstration

    return task_1a_dataframe

##############################################################

# Define features and target
def identify_features_and_targets(encoded_dataframe):
    '''
    Purpose:
    ---
    The purpose of this function is to define the features and
    the required target labels. The function returns a python list
    in which the first item is the selected features and second 
    item is the target label

    Input Arguments:
    ---
    `encoded_dataframe`: [Dataframe]
                        Pandas dataframe that has all the features mapped to 
                        numbers starting from zero

    Returns:
    ---
    `features_and_targets`: [list]
                            python list in which the first item is the 
                            selected features and second item is the target label

    Example call:
    ---
    features_and_targets = identify_features_and_targets(encoded_dataframe)
    '''

    #################    ADD YOUR CODE HERE    ##################
    X = encoded_dataframe.drop(columns=['LeaveOrNot'])
    y = encoded_dataframe['LeaveOrNot']
    return X, y

##############################################################

# Data Scaling (Standardization)
def data_scaling(X_train, X_test):
    '''
    Purpose:
    ---
    This function scales the training and testing data using StandardScaler.

    Input Arguments:
    ---
    `X_train`: [array-like]
               Training features

    `X_test`: [array-like]
              Testing features

    Returns:
    ---
    `X_train_scaled`: [array-like]
                      Scaled training features

    `X_test_scaled`: [array-like]
                     Scaled testing features

    Example call:
    ---
    X_train_scaled, X_test_scaled = data_scaling(X_train, X_test)
    '''

    #################    ADD YOUR CODE HERE    ##################
    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)
    return X_train_scaled, X_test_scaled

##############################################################

# Convert data to PyTorch tensors
def load_as_tensors(features_and_targets):
    '''
    Purpose:
    ---
    This function loads your data (both training and validation)
    as PyTorch tensors. Here you will have to split the dataset for training 
    and validation, and then load them as tensors. 
    Training of the model requires iterating over the training tensors. 
    Hence the training sensors need to be converted to iterable dataset
    object.

    Input Arguments:
    ---
    `features_and_targets`: [list]
                           python list in which the first item is the 
                           selected features and second item is the target label

    Returns:
    ---
    `tensors_and_iterable_training_data`: [list]
                                         Items:
                                         [0]: X_train_tensor: Training features loaded into Pytorch array
                                         [1]: y_train_tensor: Training labels as Pytorch tensor
                                         [2]: X_test_tensor: Feature tensors in validation data
                                         [3]: y_test_tensor: Target labels as tensor in validation data

    Example call:
    ---
    tensors_and_iterable_training_data = load_as_tensors(features_and_targets)
    '''

    #################    ADD YOUR CODE HERE    ##################
    X_train, X_test, y_train, y_test = train_test_split(features_and_targets[0], features_and_targets[1], test_size=0.2, random_state=42)
    
    X_train_tensor = torch.tensor(X_train.values, dtype=torch.float32)
    y_train_tensor = torch.tensor(y_train.values, dtype=torch.float32)
    X_test_tensor = torch.tensor(X_test.values, dtype=torch.float32)
    y_test_tensor = torch.tensor(y_test.values, dtype=torch.float32)
    
    return X_train_tensor, y_train_tensor, X_test_tensor, y_test_tensor

##############################################################

# Define the neural network model
class Salary_Predictor(nn.Module):
    def __init__(self):
        super(Salary_Predictor, self).__init__()
        self.fc1 = nn.Linear(input_size, 64)
        self.fc2 = nn.Linear(64, 32)
        self.fc3 = nn.Linear(32, 1)
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        x = torch.relu(self.fc1(x))
        x = torch.relu(self.fc2(x))
        x = self.fc3(x)
        x = self.sigmoid(x)
        return x

##############################################################

# Training function
def train_model(model, number_of_epochs, tensors_and_iterable_training_data, loss_function, optimizer):
    '''
    Purpose:
    ---
    This function trains the neural network model.

    Input Arguments:
    ---
    `model`: [nn.Module]
             Neural network model

    `number_of_epochs`: [integer]
                        Number of training epochs

    `tensors_and_iterable_training_data`: [list]
                                         Items:
                                         [0]: X_train_tensor: Training features loaded into PyTorch array
                                         [1]: y_train_tensor: Training labels as PyTorch tensor
                                         [2]: X_test_tensor: Feature tensors in validation data
                                         [3]: y_test_tensor: Target labels as tensor in validation data

    `loss_function`: [torch.nn]
                      Loss function for the model

    `optimizer`: [torch.optim]
                  Optimizer for updating model parameters

    Returns:
    ---
    `trained_model`

    Example call:
    ---
    trained_model = train_model(model, number_of_epochs, tensors_and_iterable_training_data, loss_function, optimizer)
    '''

    #################    ADD YOUR CODE HERE    ##################
    X_train_tensor, y_train_tensor, X_test_tensor, y_test_tensor = tensors_and_iterable_training_data
    
    for epoch in range(number_of_epochs):
        optimizer.zero_grad()
        outputs = model(X_train_tensor)
        loss = loss_function(outputs, y_train_tensor.view(-1, 1))
        loss.backward()
        optimizer.step()

        if (epoch + 1) % 10 == 0:
            print(f'Epoch [{epoch + 1}/{number_of_epochs}], Loss: {loss.item()}')
    
    return model

##############################################################

# Evaluation function
def evaluate_model(trained_model, tensors_and_iterable_training_data):
    '''
    Purpose:
    ---
    This function evaluates the trained model on the testing data.

    Input Arguments:
    ---
    `trained_model`: [nn.Module]
                     Trained neural network model

    `tensors_and_iterable_training_data`: [list]
                                         Items:
                                         [0]: X_train_tensor: Training features loaded into PyTorch array
                                         [1]: y_train_tensor: Training labels as PyTorch tensor
                                         [2]: X_test_tensor: Feature tensors in validation data
                                         [3]: y_test_tensor: Target labels as tensor in the validation data

    Returns:
    ---
    `accuracy`: [float]
                Accuracy on the testing data

    Example call:
    ---
    accuracy = evaluate_model(trained_model, tensors_and_iterable_training_data)
    '''

    X_train_tensor, y_train_tensor, X_test_tensor, y_test_tensor = tensors_and_iterable_training_data
    with torch.no_grad():
        trained_model.eval()
        test_outputs = trained_model(X_test_tensor)
        predicted = (test_outputs >= 0.5).float()
        accuracy = (predicted == y_test_tensor.view(-1, 1)).sum().item() / len(y_test_tensor)
        return accuracy * 100

##############################################################

if __name__ == "__main__":
    # Load and preprocess the dataset
    file_path = 'task_1a_dataset.csv'
    data = load_dataset(file_path)
    preprocessed_data = data_preprocessing(data)
    
    # Identify features and targets
    features_and_targets = identify_features_and_targets(preprocessed_data)
    
    # Convert data to PyTorch tensors
    tensors_and_iterable_training_data = load_as_tensors(features_and_targets)
    
    # Initialize the model
    input_size = features_and_targets[0].shape[1]
    model = Salary_Predictor()
    
    # Define loss function and optimizer
    criterion = nn.BCELoss()
    optimizer = optim.Adam(model.parameters(), lr=0.001)
    
    # Training
    num_epochs = 100
    trained_model = train_model(model, num_epochs, tensors_and_iterable_training_data, criterion, optimizer)
    
    # Evaluation
    accuracy = evaluate_model(trained_model, tensors_and_iterable_training_data)
    print(f'Test Accuracy: {accuracy:.2f}%')
    
    # Save the trained model if needed
    torch.save(trained_model.state_dict(), 'task_1a_trained_model.pth')
